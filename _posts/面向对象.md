# 笔记 : 理解内存！

## 内存分析：TestCircle

只要有形參，就在Stack中分配内存空间。

当写一个方法时，需要考虑：
1） 方法名字
2） 方法参数
3） 方法返回值

## this 关键字

对 this 所在类的对引用，或者constructor。
处理方法中成员变量和参数重名的情况。

## static 关键字

static 成员变量：静态成员变量，类的公用变量，第一次使用时被初始化。

static 方法： 不能访问非静态成员（变量和方法）。**静态方法不再是针对某个对象的调用，所以不能访问非静态成员**

Cat.java  

## package 和 import

包：用来解决类名冲突。

注意：class 文件的最上层包的父目录需要在 classpath 下。执行一个类，需要写全包名。

## 访问控制

private 只有类内部. 子类只能看不能用private的instance。
default 只有类内部和同一个包的
protected 类内部，同一个包，子类
public 都能访问

class 前面只有public 和 default。

## 重写

重写是使用 copy。重写的方法不能比被重写的方法更严格

## 继承中的构造方法

子类构造过程中，必须调用父类的构造方法
super（argument）
this（argument）
如果调用super构造，必须放在第一行。
如果没有显示调用父类构造方法，则系统默认使用无參构造方法
如果父类没有无參构造方法，子类没有显示调用父类其他构造方法，则编译出错。

## toString

## equals()

对于对象而言，“==”比较的是对象，而”equals()“一般需要重写，进行对象的比较。

实现流程：

1. 判断输入对象是否为null：if(obj == null) return false
2. 判断输入的对象是否为比较对象：instance of
3. 比较对象内的属性

## 对象转型

父类对象的引用不能使用子类对象**自己**(自己指的是没有在父类中出现过。)的成员。
可以使用 instanceof 来判别一个类是否与另一个类同类，或者是另一个类的子类

## 动态绑定——多态

对子类的重写的**方法**的动态调用。

解释一下什么是动态绑定。 

多态存在的三个必要条件：

1. 继承
2. 重写
3. 父类引用指向子类对象

==重现一下lady养宠物的小程序。==

## 抽象类

抽象方法的意义：   
只需要定义不需要实现。为什么要定义，因为动态绑定必须有重写机制。

public abstract void enjoyed();

**当一个类含有抽象方法时，这个类必须是抽象类。**

## Final

final 变量不能被改变
final 方法不能被重写
final class 不能被继承

## 接口

只有抽象方法和常量值的定义的集合。
常量必须：public static final 
方法不需要写abstract，不可以有body。
你只可以使用你的引用接口所定义的方法。

*通过不同角度看问题～*

测试valuable小程序。


## 异常处理

> 程序是调出来的！

Throwable：
Error
Exception：
Runtime Exception（经常出问题的，一般不需要catch）
finally 一般用于关闭文件，删除临时文件
catch 异常是注意从小到大

**重写方法需要与原方法所抛出异常类型一致的异常或者不抛出异常**